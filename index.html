<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Will Thorley — Profile + Hockey Game</title>
  <style>
    :root{
      --bg:#0b63d6;
      --card:#fff;
    }
    body{
      font-family:Inter,system-ui,Arial,sans-serif;
      background:var(--bg);
      color:#fff;
      margin:0;
    }
    .corner-profile{
      position:fixed;top:12px;right:12px;
      display:flex;align-items:center;gap:8px;
    }
    .corner-profile img{
      width:56px;height:56px;border-radius:50%;
      border:2px solid rgba(255,255,255,0.6);
      object-fit:cover;
    }
    .container{max-width:980px;margin:90px auto;padding:24px}
    .card{
      background:#fff;color:#000;
      padding:18px;border-radius:12px;
      box-shadow:0 6px 18px rgba(15,23,42,0.2);
      margin-bottom:18px;
    }
    .stats-grid{display:flex;gap:18px;margin:12px 0}
    .stats-grid>div{
      background:#f9fafb;padding:12px;border-radius:8px;
      min-width:90px;text-align:center;
    }
    table { width:100%; border-collapse: collapse; margin-top: 12px; }
    th, td { padding: 8px; border: 1px solid #ccc; text-align: left; }
    #gameCard { text-align:center; }
    #gameCanvas {
      background: linear-gradient(#e5e7eb,#d1d5db);
      border:3px solid #333;
      border-radius:8px;
      display:block;margin:10px auto;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    }
    button {
      background:#0b63d6;color:#fff;
      padding:8px 16px;margin:4px;
      border:none;border-radius:6px;
      cursor:pointer;font-weight:600;
    }
    button:hover{background:#084a9c;}
    .controls {
      margin-top:8px;font-size:14px;color:#333;text-align:left;
    }
    .hud {
      display:flex;justify-content:center;gap:16px;align-items:center;margin:8px 0;
    }
    .hud .box { background:#f3f4f6;padding:8px 12px;border-radius:8px; }
    .small { font-size:12px;color:#6b7280; }
    .mode-select { margin-bottom:10px; }
    .center { text-align:center; }
  </style>
</head>
<body>
  <header class="corner-profile">
    <img id="profilePic" src="assets/profile.jpg" alt="Will Thorley" />
    <div id="profileName">Will Thorley</div>
  </header>

  <main class="container">
    <section class="card">
      <h2>About Me</h2>
      <p>
        I play for <strong>Boston Advantage 2012 Elite</strong>. 
        I’ve also competed in the prestigious <strong>Quebec International Pee-Wee Tournament</strong> with the Flames, 
        and played in <strong>The Brick Invitational</strong> with the Jr. Bruins.
      </p>
    </section>

    <section class="card">
      <h2>Boston Advantage 2012 Elite — Season Summary</h2>
      <div class="stats-grid">
        <div><strong>Wins</strong><div id="wins">2</div></div>
        <div><strong>Losses</strong><div id="losses">1</div></div>
        <div><strong>Ties</strong><div id="ties">2</div></div>
      </div>
      <p>
        <strong>2025 Record:</strong> 2-1-2 (Wins-Losses-Ties)<br>
        <small>Source: <a href="https://www.myhockeyrankings.com/team_info.php?t=4488&y=2025" target="_blank">MyHockeyRankings</a></small>
      </p>

      <h3>Past Games (2025)</h3>
      <table>
        <thead>
          <tr>
            <th>Opponent</th><th>Result</th>
          </tr>
        </thead>
        <tbody>
          <tr><td>Wizards</td><td>L 1-5</td></tr>
          <tr><td>Jr Bruins</td><td>T 3-3</td></tr>
          <tr><td>Giants</td><td>W</td></tr>
          <tr><td>Winter Club</td><td>W 4-3</td></tr>
          <tr><td>Patriots</td><td>T 3-3</td></tr>
        </tbody>
      </table>
    </section>

    <section id="gameCard" class="card">
      <h2>Mini Hockey Game — More Realistic</h2>

      <div id="menu" class="mode-select center">
        <p>Select Mode and Difficulty:</p>
        <button onclick="startGame('1p','easy')">1P vs AI (Easy)</button>
        <button onclick="startGame('1p','med')">1P vs AI (Medium)</button>
        <button onclick="startGame('1p','hard')">1P vs AI (Hard)</button>
        <button onclick="startGame('2p')">2 Players (Local)</button>
      </div>

      <div id="scoreboard" style="display:none;" class="hud">
        <div class="box"><strong>Player 1</strong><div id="p1Score">0</div></div>
        <div class="box"><strong>Player 2 / AI</strong><div id="p2Score">0</div></div>
        <div class="box small">Period: <span id="period">1</span>/2</div>
        <div class="box small">Time: <span id="clock">02:00</span></div>
        <button onclick="resetGame()">Home</button>
      </div>

      <canvas id="gameCanvas" width="640" height="360"></canvas>

      <div class="controls card">
        <strong>Controls</strong>
        <ul>
          <li>Player 1: Move with <strong>W A S D</strong>, <strong>Space</strong> to shoot (charged by hold).</li>
          <li>Player 2 (if 2P): Move with <strong>↑ ↓ ← →</strong>, <strong>Enter</strong> to shoot.</li>
          <li>AI mode: AI will chase puck, defend, and shoot when in position.</li>
        </ul>
        <p class="small">Game rules are simplified: 2 periods, 2 minutes each. After a goal there's a faceoff at center. Puck has friction and bounces off boards. Collisions with players transfer momentum.</p>
      </div>
    </section>
  </main>

  <script>
    /* -------------------------
       Mini Hockey — Realistic-ish
       Single-file game added to your page
       ------------------------- */

    // Canvas + context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // HUD elements
    const menu = document.getElementById('menu');
    const scoreboard = document.getElementById('scoreboard');
    const p1ScoreEl = document.getElementById('p1Score');
    const p2ScoreEl = document.getElementById('p2Score');
    const periodEl = document.getElementById('period');
    const clockEl = document.getElementById('clock');

    // Game state
    let mode = 'menu'; // 'menu', 'running', 'paused'
    let players = [];
    let puck;
    let lastTime = 0;
    let p1Score = 0, p2Score = 0;
    let period = 1;
    const TOTAL_PERIODS = 2;
    const PERIOD_SECONDS = 120; // 2-minute periods
    let periodRemaining = PERIOD_SECONDS;
    let aiDifficulty = 'med';

    // Physics settings
    const FRICTION = 0.995;   // puck friction per frame
    const PLAYER_FRICTION = 0.9;
    const MAX_PLAYER_SPEED = 2.2;
    const PUCK_RADIUS = 8;
    const PLAYER_RADIUS = 14;

    // Goals: width and positions
    const GOAL_WIDTH = 110;
    const GOAL_DEPTH = 8;

    // Input state
    const keys = {};

    // Utility helpers
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

    // Entities
    class Puck {
      constructor(x,y){
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.radius = PUCK_RADIUS;
      }
      update(dt){
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // friction
        this.vx *= Math.pow(FRICTION, dt*60);
        this.vy *= Math.pow(FRICTION, dt*60);

        // small clamp near zero
        if (Math.abs(this.vx) < 0.01) this.vx = 0;
        if (Math.abs(this.vy) < 0.01) this.vy = 0;

        // bounce off boards (canvas edges), but allow goals (gaps)
        // left and right sides are boards except goal openings at top/bottom center?
        // We'll put goals on left and right center.
        if (this.y - this.radius <= 0) { this.y = this.radius; this.vy *= -0.7; }
        if (this.y + this.radius >= canvas.height) { this.y = canvas.height - this.radius; this.vy *= -0.7; }

        // left wall (except goal opening)
        const goalTop = (canvas.height - GOAL_WIDTH)/2;
        const goalBottom = goalTop + GOAL_WIDTH;
        if (this.x - this.radius <= 0) {
          // check if inside left goal opening (goalTop..goalBottom)
          if (this.y > goalTop && this.y < goalBottom) {
            // it's a goal on the left (player 2 scores)
            scoreGoal(2);
            return;
          } else {
            this.x = this.radius; this.vx *= -0.7;
          }
        }
        if (this.x + this.radius >= canvas.width) {
          if (this.y > goalTop && this.y < goalBottom) {
            // goal on the right (player 1 scores)
            scoreGoal(1);
            return;
          } else {
            this.x = canvas.width - this.radius; this.vx *= -0.7;
          }
        }
      }
      draw(){
        // puck shadow
        ctx.beginPath();
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.ellipse(this.x+2, this.y+3, this.radius+4, this.radius/2+2, 0,0,Math.PI*2);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = '#111827';
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();

        // highlight
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.arc(this.x-3, this.y-3, this.radius*0.6, 0, Math.PI*2);
        ctx.fill();
      }
    }

    class Player {
      constructor(x,y, id, isAI=false){
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.radius = PLAYER_RADIUS;
        this.id = id;
        this.isAI = isAI;
        this.holdShootPower = 0; // for charging shots
        this.maxShootPower = 8.0;
      }
      update(dt){
        if (!this.isAI && this.id === 1) {
          // Player1 WASD
          let ax=0, ay=0;
          if (keys['KeyW']) ay -= 1;
          if (keys['KeyS']) ay += 1;
          if (keys['KeyA']) ax -= 1;
          if (keys['KeyD']) ax += 1;
          const mag = Math.hypot(ax,ay);
          if (mag > 0) { ax/=mag; ay/=mag; }
          this.vx += ax * 0.18 * dt*60;
          this.vy += ay * 0.18 * dt*60;

        } else if (!this.isAI && this.id === 2) {
          // Player2 arrow keys
          let ax=0, ay=0;
          if (keys['ArrowUp']) ay -= 1;
          if (keys['ArrowDown']) ay += 1;
          if (keys['ArrowLeft']) ax -= 1;
          if (keys['ArrowRight']) ax += 1;
          const mag = Math.hypot(ax,ay);
          if (mag > 0) { ax/=mag; ay/=mag; }
          this.vx += ax * 0.18 * dt*60;
          this.vy += ay * 0.18 * dt*60;

        } else if (this.isAI){
          // Simple AI: chase puck if on its half, defend if opponent near goal
          aiBehavior(this, dt);
        }

        // clamp speed
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > MAX_PLAYER_SPEED) {
          this.vx = (this.vx / speed) * MAX_PLAYER_SPEED;
          this.vy = (this.vy / speed) * MAX_PLAYER_SPEED;
        }

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // friction for players
        this.vx *= Math.pow(PLAYER_FRICTION, dt*60);
        this.vy *= Math.pow(PLAYER_FRICTION, dt*60);

        // keep inside rink
        this.x = clamp(this.x, this.radius+5, canvas.width - this.radius-5);
        this.y = clamp(this.y, this.radius+5, canvas.height - this.radius-5);
      }
      draw(){
        // jersey
        ctx.beginPath();
        ctx.fillStyle = (this.id===1) ? '#ef4444' : '#111827';
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();

        // number
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.id, this.x, this.y);
      }
    }

    // AI behavior (basic)
    function aiBehavior(p, dt){
      // Difficulty parameters
      const diff = aiDifficulty;
      let aggression = 0.8;
      let reaction = 0.06;
      if (diff === 'easy') { aggression = 0.5; reaction = 0.035; }
      if (diff === 'med') { aggression = 0.75; reaction = 0.055; }
      if (diff === 'hard') { aggression = 0.95; reaction = 0.085; }

      // distances
      const dx = puck.x - p.x;
      const dy = puck.y - p.y;
      const d = Math.hypot(dx,dy);

      // if we're near our goal area, prioritize defense
      const isLeftSide = (p.id === 2); // Player 2 defends right? we'll place P1 left P2 right
      const ourGoalX = (isLeftSide ? canvas.width - 10 : 10);

      // defensive behavior: if puck near our goal x, move toward defensive spot
      const nearOurGoal = (Math.abs(puck.x - ourGoalX) < canvas.width * 0.2);

      if (nearOurGoal && Math.random() < (1 - aggression)) {
        // move to protect center of goal
        const targetY = canvas.height/2 + (Math.random()*40-20);
        const tx = clamp(ourGoalX + (isLeftSide ? -70 : 70), p.radius+10, canvas.width - p.radius-10);
        const ty = clamp(targetY, p.radius+10, canvas.height - p.radius-10);
        p.vx += (tx - p.x) * reaction * dt*60;
        p.vy += (ty - p.y) * reaction * dt*60;
      } else {
        // chase the puck with some lead
        const lead = Math.min(50, d * 0.3);
        const tx = puck.x + (puck.vx * lead);
        const ty = puck.y + (puck.vy * lead);
        p.vx += (tx - p.x) * reaction * dt*60;
        p.vy += (ty - p.y) * reaction * dt*60;
      }

      // shooting decision: if close enough to puck and facing goal, shoot
      if (d < p.radius + puck.radius + 8 && Math.random() < aggression*0.5) {
        // shoot toward opponent goal
        const goalX = (p.id === 2) ? 10 : canvas.width - 10;
        const gx = goalX;
        const gy = canvas.height/2 + (Math.random()*40-20);
        const dxg = gx - puck.x, dyg = gy - puck.y;
        const mag = Math.hypot(dxg, dyg) || 1;
        const power = p.maxShootPower * (0.6 + Math.random()*0.4);
        puck.vx = (dxg/mag) * power;
        puck.vy = (dyg/mag) * power;
      }
    }

    // Handle collisions: player-puck and player-player (simple)
    function handleCollisions(){
      // player-puck
      for (const pl of players){
        const d = dist(pl, puck);
        const minD = pl.radius + puck.radius;
        if (d < minD && d > 0) {
          // push puck away based on player velocity and position
          const nx = (puck.x - pl.x) / d;
          const ny = (puck.y - pl.y) / d;
          // transfer some of player's velocity + an impulse
          const relativeSpeed = pl.vx*nx + pl.vy*ny;
          puck.vx += nx * (0.6 + relativeSpeed*0.8) + pl.vx*0.2;
          puck.vy += ny * (0.6 + relativeSpeed*0.8) + pl.vy*0.2;

          // slightly push player back
          pl.vx -= nx * 0.2;
          pl.vy -= ny * 0.2;

          // separate them
          const overlap = minD - d;
          puck.x += nx * overlap * 0.5;
          puck.y += ny * overlap * 0.5;
          pl.x -= nx * overlap * 0.5;
          pl.y -= ny * overlap * 0.5;
        }
      }

      // simple player-player collision to avoid stacking
      for (let i=0;i<players.length;i++){
        for (let j=i+1;j<players.length;j++){
          const a = players[i], b = players[j];
          const d = dist(a,b);
          const minD = a.radius + b.radius;
          if (d < minD && d > 0) {
            const nx = (b.x - a.x) / d;
            const ny = (b.y - a.y) / d;
            const overlap = minD - d;
            a.x -= nx * overlap * 0.5;
            a.y -= ny * overlap * 0.5;
            b.x += nx * overlap * 0.5;
            b.y += ny * overlap * 0.5;

            // swap velocities a bit
            const dvx = (b.vx - a.vx) * 0.5;
            const dvy = (b.vy - a.vy) * 0.5;
            a.vx += dvx; a.vy += dvy;
            b.vx -= dvx; b.vy -= dvy;
          }
        }
      }
    }

    // Drawing rink with goals
    function drawRink(){
      // ice
      ctx.fillStyle = '#e6f0ff';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // center line
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,0,0,0.7)';
      ctx.fillRect(canvas.width/2 - 2, 0, 4, canvas.height);

      // center circle
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 2;
      ctx.arc(canvas.width/2, canvas.height/2, 60, 0, Math.PI*2);
      ctx.stroke();

      // goals: left and right gaps
      const goalTop = (canvas.height - GOAL_WIDTH)/2;
      ctx.fillStyle = '#111827';
      // left boards
      ctx.fillRect(0,0,6,goalTop);
      ctx.fillRect(0,goalTop+GOAL_WIDTH,6,canvas.height-(goalTop+GOAL_WIDTH));
      // right boards
      ctx.fillRect(canvas.width-6,0,6,goalTop);
      ctx.fillRect(canvas.width-6,goalTop+GOAL_WIDTH,6,canvas.height-(goalTop+GOAL_WIDTH));

      // draw goal lines for visual
      ctx.fillStyle = '#d1d5db';
      ctx.fillRect(6, goalTop, 6, GOAL_WIDTH);
      ctx.fillRect(canvas.width-12, goalTop, 6, GOAL_WIDTH);

      // goal posts
      ctx.fillStyle = '#ef4444';
      ctx.fillRect(0, goalTop - 4, 12, 4);
      ctx.fillRect(0, goalTop + GOAL_WIDTH, 12, 4);
      ctx.fillRect(canvas.width - 12, goalTop - 4, 12, 4);
      ctx.fillRect(canvas.width - 12, goalTop + GOAL_WIDTH, 12, 4);
    }

    // Score handling
    function scoreGoal(who){
      if (who === 1) p1Score++;
      else p2Score++;
      updateHUD();

      // faceoff after short delay (use setTimeout)
      mode = 'paused';
      setTimeout(() => {
        resetFaceoff();
        if (period > TOTAL_PERIODS && (periodRemaining <= 0)) {
          // end of game
        } else {
          mode = 'running';
        }
      }, 900);
    }

    function updateHUD(){
      p1ScoreEl.textContent = p1Score;
      p2ScoreEl.textContent = p2Score;
      periodEl.textContent = period;
    }

    // Game control functions
    function startGame(gm, difficulty){
      // setup players and puck
      aiDifficulty = difficulty || 'med';
      mode = 'running';
      menu.style.display = 'none';
      scoreboard.style.display = 'flex';
      p1Score = 0; p2Score = 0;
      period = 1; periodRemaining = PERIOD_SECONDS;
      spawnEntities(gm);
      updateHUD();
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function spawnEntities(gm){
      players = [];
      // Player 1 starts left center
      const p1 = new Player(canvas.width*0.25, canvas.height/2, 1, false);
      let p2;
      if (gm === '2p') {
        p2 = new Player(canvas.width*0.75, canvas.height/2, 2, false);
      } else {
        p2 = new Player(canvas.width*0.75, canvas.height/2, 2, true);
      }
      players.push(p1, p2);

      // Puck at center
      puck = new Puck(canvas.width/2, canvas.height/2);
      // small random kickoff velocity
      puck.vx = (Math.random()*2-1) * 0.4;
      puck.vy = (Math.random()*2-1) * 0.4;

      // reset scores in HUD
      p1ScoreEl.textContent = p1Score;
      p2ScoreEl.textContent = p2Score;
      periodEl.textContent = period;
      clockEl.textContent = formatTime(periodRemaining);
    }

    function resetFaceoff() {
      // center players and puck
      players[0].x = canvas.width*0.25; players[0].y = canvas.height/2; players[0].vx = players[0].vy = 0;
      players[1].x = canvas.width*0.75; players[1].y = canvas.height/2; players[1].vx = players[1].vy = 0;
      puck.x = canvas.width/2; puck.y = canvas.height/2; puck.vx = (Math.random()*2-1)*0.4; puck.vy = (Math.random()*2-1)*0.4;
    }

    function resetGame(){
      mode = 'menu';
      menu.style.display = 'block';
      scoreboard.style.display = 'none';
      // stop animation by clearing players/puck
      players = []; puck = null;
    }

    // Format time mm:ss
    function formatTime(sec){
      const s = Math.max(0, Math.floor(sec));
      const mm = Math.floor(s / 60);
      const ss = s % 60;
      return (mm<10 ? '0'+mm : mm) + ':' + (ss<10 ? '0'+ss : ss);
    }

    // Main loop
    function loop(ts){
      const dt = Math.min(1/30, (ts - lastTime) / 1000 || 0.016);
      lastTime = ts;

      if (mode === 'running') {
        // update physics
        for (const pl of players) pl.update(dt);
        if (puck) puck.update(dt);

        handleCollisions();

        // update timer
        periodRemaining -= dt;
        if (periodRemaining <= 0) {
          // advance period
          if (period < TOTAL_PERIODS) {
            period++;
            periodRemaining = PERIOD_SECONDS;
            // reset positions
            resetFaceoff();
          } else {
            // game over
            periodRemaining = 0;
            mode = 'paused';
            // show final state (you could extend with final modal)
          }
        }
        clockEl.textContent = formatTime(periodRemaining);
      }

      // draw
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawRink();

      // draw goals count maybe
      // draw entities
      if (puck) puck.draw();
      for (const pl of players) pl.draw();

      // small overlay for scores on rink
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.font = '18px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`P1: ${p1Score}`, 12, 24);
      ctx.textAlign = 'right';
      ctx.fillText(`P2: ${p2Score}`, canvas.width - 12, 24);

      if (mode !== 'menu') requestAnimationFrame(loop);
    }

    // Input handlers for shooting
    document.addEventListener('keydown', (e) => {
      keys[e.code] = true;

      // P1 shoot (space)
      if (e.code === 'Space') {
        // prevent page scroll
        e.preventDefault();
        // charge power
        const p = players[0];
        if (p) p.holdShootPower = Math.min(p.maxShootPower, p.holdShootPower + 0.6);
      }

      // P2 shoot (Enter)
      if (e.code === 'Enter' && players[1] && !players[1].isAI) {
        const p = players[1];
        p.holdShootPower = Math.min(p.maxShootPower, p.holdShootPower + 0.6);
      }
    });
    document.addEventListener('keyup', (e) => {
      keys[e.code] = false;

      // release shot for P1
      if (e.code === 'Space') {
        const p = players[0];
        if (p) performShoot(p);
        if (p) p.holdShootPower = 0;
      }
      // release shot for P2
      if (e.code === 'Enter') {
        const p = players[1];
        if (p) performShoot(p);
        if (p) p.holdShootPower = 0;
      }
    });

    function performShoot(player){
      if (!puck) return;
      // if player near puck, shoot puck toward goal with power
      const d = dist(player, puck);
      if (d <= player.radius + puck.radius + 10) {
        // aim towards opponent goal
        const goalX = (player.id === 1) ? canvas.width - 10 : 10;
        const gx = goalX;
        const gy = canvas.height/2 + (Math.random()*40-20);
        const dx = gx - puck.x, dy = gy - puck.y;
        const mag = Math.hypot(dx,dy) || 1;
        const basePower = clamp(player.holdShootPower, 1.8, player.maxShootPower);
        const randomness = 0.6 * (Math.random()-0.5);
        puck.vx = (dx/mag) * (basePower + randomness) + player.vx*0.6;
        puck.vy = (dy/mag) * (basePower + randomness) + player.vy*0.6;
      } else {
        // if not physically touching puck, try passing / poke - apply a small directional push
        const dx = puck.x - player.x, dy = puck.y - player.y;
        const mag = Math.hypot(dx,dy) || 1;
        puck.vx += (dx/mag) * 1.6;
        puck.vy += (dy/mag) * 1.6;
      }
    }

    // init: draw initial rink
    drawRink();
    ctx.fillStyle = '#111827';
    ctx.font = '16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Select a mode to start', canvas.width/2, canvas.height/2 - 6);
    ctx.font = '12px Arial';
    ctx.fillText('Controls shown below. Good luck!', canvas.width/2, canvas.height/2 + 10);

    // expose to console for debugging
    window.__game = {
      startGame, resetGame, players, puck
    };

  </script>
</body>
</html>
