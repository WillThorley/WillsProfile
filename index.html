<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Will Thorley — Profile + Mini Hockey</title>
  <style>
    :root{
      --bg:#0b63d6;
      --card:#fff;
    }
    *{box-sizing:border-box}
    body{
      font-family:Inter,system-ui,Arial,sans-serif;
      background:var(--bg);
      color:#fff;
      margin:0;
      padding:0;
    }
    .corner-profile{
      position:fixed;top:12px;right:12px;
      display:flex;align-items:center;gap:8px;z-index:20
    }
    .corner-profile img{
      width:56px;height:56px;border-radius:50%;object-fit:cover;
      border:2px solid rgba(255,255,255,0.6)
    }
    .corner-profile #profileName{font-weight:600}
    .container{max-width:980px;margin:40px auto;padding:24px}
    .card{
      background:var(--card);color:#000;
      padding:14px;border-radius:12px;
      box-shadow:0 6px 18px rgba(15,23,42,0.18);
      margin-bottom:18px
    }
    .intro h1{margin:0 0 6px 0;color:#fff}
    .intro p{color:#eef3ff}
    .stats-grid{display:flex;gap:18px;margin:12px 0}
    .stats-grid>div{
      background:#f9fafb;padding:12px;border-radius:8px;min-width:90px;text-align:center
    }

    /* Game card */
    #gameCard { text-align:center; }
    #gameCanvas {
      width:500px; height:300px;
      background:#eaf6ff; border:3px solid #333; border-radius:8px;
      display:block; margin:10px auto;
    }
    .menu, .scoreboard { margin:10px 0; }
    button {
      background:#0b63d6;color:#fff;padding:8px 14px;margin:6px;border:none;border-radius:6px;cursor:pointer;font-weight:600;
    }
    button:hover { background:#084a9c; }
    .controls { color:#223; font-size:13px; margin-top:6px }
    .small { font-size:13px }
  </style>
</head>
<body>
  <header class="corner-profile">
    <img id="profilePic" src="assets/profile.jpg" alt="Will Thorley" />
    <div id="profileName">Will Thorley</div>
  </header>

  <main class="container">
    <section class="intro">
      <h1>Will Thorley</h1>
      <p>Player / Coach for <strong>Boston Advantage 2012 Elite</strong>. Season record below — the mini-game is under the card.</p>
    </section>

    <section id="team-stats" class="card">
      <h2 style="color:#0b63d6">Boston Advantage 2012 Elite — Season Summary</h2>
      <div class="stats-grid">
        <div><strong>Wins</strong><div id="wins">2</div></div>
        <div><strong>Losses</strong><div id="losses">1</div></div>
        <div><strong>Ties</strong><div id="ties">2</div></div>
      </div>
      <div class="small">Season stats are separate from the mini-game scoreboard.</div>
    </section>

    <section id="gameCard" class="card">
      <h2>Mini Hockey Game</h2>

      <div id="homeScreen" class="menu">
        <p>Select Mode:</p>
        <button onclick="startGame('1p')">1 Player vs AI</button>
        <button onclick="startGame('2p')">2 Players</button>
        <div class="controls">
          Controls:
          <ul style="text-align:left;display:inline-block;margin:6px 0 0 12px;padding-left:16px;color:#333">
            <li><strong>P1</strong>: Arrow keys to move, <strong>Space</strong> = shoot, <strong>Shift</strong> = poke-check</li>
            <li><strong>P2</strong>: WASD to move, <strong>Enter</strong> = shoot, <strong>/</strong> = poke-check</li>
          </ul>
        </div>
      </div>

      <div id="scoreboard" style="display:none;">
        <strong>Player 1:</strong> <span id="p1Score">0</span> |
        <strong>Player 2 / AI:</strong> <span id="p2Score">0</span>
        <button onclick="goHome()">Home</button>
      </div>

      <canvas id="gameCanvas" width="500" height="300" style="display:block"></canvas>
      <div id="hint" class="small" style="color:#223">Tip: move near the puck with your stick (blade) to pick it up; press your shoot key to release.</div>
    </section>
  </main>

  <script>
    // canvas & context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // UI elements
    const homeScreen = document.getElementById('homeScreen');
    const scoreboardEl = document.getElementById('scoreboard');
    const p1ScoreEl = document.getElementById('p1Score');
    const p2ScoreEl = document.getElementById('p2Score');

    // state
    let mode = null; // '1p' | '2p'
    let keys = {};
    let loopId = null;
    let p1Score = 0, p2Score = 0;

    // Player objects
    function makePlayer(x,y,controls,isAI=false){
      return {
        x, y,
        r: 12, // visual size for stick pivot
        speed: 3.2,
        dir: 0, // facing angle in radians (0 = right)
        controls,
        isAI: !!isAI,
        holding: false, // whether this player currently holds the puck
        bladeOffset: 30, // length from center to blade end
        pokeCooldown: 0
      };
    }

    let p1, p2, puck;

    // puck object
    function makePuck(){
      return { x: canvas.width/2, y: canvas.height/2, r:6, vx:0, vy:0, attachedTo: null };
    }

    // keyboard
    window.addEventListener('keydown', e => { keys[e.key] = true; /*prevent page-scrolling on arrows/space*/ if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault(); });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    // start/reset
    function startGame(selectedMode){
      mode = selectedMode;
      homeScreen.style.display = 'none';
      scoreboardEl.style.display = 'block';
      p1Score = 0; p2Score = 0; updateScoreboard();

      p1 = makePlayer(80, canvas.height/2, {up:'ArrowUp',down:'ArrowDown',left:'ArrowLeft',right:'ArrowRight',shoot:' ',poke:'Shift'}, false);
      if(mode === '2p'){
        p2 = makePlayer(canvas.width-80, canvas.height/2, {up:'w',down:'s',left:'a',right:'d',shoot:'Enter',poke:'/'}, false);
      } else {
        p2 = makePlayer(canvas.width-80, canvas.height/2, {shoot:'Enter',poke:'/'}, true);
      }

      puck = makePuck();
      cancelAnimationFrame(loopId);
      loop();
    }

    function goHome(){
      cancelAnimationFrame(loopId);
      mode = null;
      homeScreen.style.display = 'block';
      scoreboardEl.style.display = 'none';
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    function updateScoreboard(){
      p1ScoreEl.textContent = p1Score;
      p2ScoreEl.textContent = p2Score;
    }

    // helper: stick end coordinates for a player
    function stickEnd(p){
      const ex = p.x + Math.cos(p.dir) * p.bladeOffset;
      const ey = p.y + Math.sin(p.dir) * p.bladeOffset;
      return {x: ex, y: ey};
    }

    // attach logic: check blade vs puck
    function tryAttach(playerIndex){
      const pl = (playerIndex === 1 ? p1 : p2);
      if(!pl) return;
      if(puck.attachedTo !== null) return;
      const blade = stickEnd(pl);
      const dx = puck.x - blade.x;
      const dy = puck.y - blade.y;
      const d = Math.hypot(dx,dy);
      if(d < 10){ // close enough to attach
        puck.attachedTo = playerIndex;
        pl.holding = true;
        // zero puck velocity
        puck.vx = 0; puck.vy = 0;
      }
    }

    // shoot logic
    function shoot(playerIndex){
      const pl = (playerIndex===1 ? p1 : p2);
      if(!pl) return;
      if(puck.attachedTo === playerIndex){
        // release with speed
        const power = 8 + Math.random()*1.5; // small variation
        puck.vx = Math.cos(pl.dir) * power;
        puck.vy = Math.sin(pl.dir) * power;
        puck.attachedTo = null;
        pl.holding = false;
        pl.pokeCooldown = 10; // small cooldown
      } else {
        // if puck is near blade but not attached, try to attach (quick stick pickup)
        tryAttach(playerIndex);
      }
    }

    // poke check: attempt to steal/knock loose when near a holding player
    function pokeCheck(playerIndex){
      const attacker = (playerIndex===1 ? p1 : p2);
      const defender = (playerIndex===1 ? p2 : p1);
      if(!attacker || !defender) return;
      // if attacker near defender's blade
      const atkBlade = stickEnd(attacker);
      const defBlade = stickEnd(defender);
      const dist = Math.hypot(atkBlade.x - defBlade.x, atkBlade.y - defBlade.y);
      if(dist < 28) {
        // if defender is holding, knock puck loose and give it some velocity away from defender
        if(puck.attachedTo === (playerIndex===1?2:1)) {
          puck.attachedTo = null;
          defender.holding = false;
          const awayX = atkBlade.x - defBlade.x;
          const awayY = atkBlade.y - defBlade.y;
          const mag = Math.hypot(awayX, awayY) || 1;
          puck.vx = (awayX/mag) * 6;
          puck.vy = (awayY/mag) * 6;
        } else {
          // if puck not attached, give small nudge in attack direction
          const pdx = puck.x - atkBlade.x;
          const pdy = puck.y - atkBlade.y;
          const pd = Math.hypot(pdx,pdy);
          if(pd < 20) {
            puck.vx += (pdx/pd) * 3;
            puck.vy += (pdy/pd) * 3;
          }
        }
        attacker.pokeCooldown = 12;
      }
    }

    // physics & AI
    function update() {
      // handle player inputs & simple AI
      // P1 controls
      handlePlayerInput(p1, keys);

      if(mode === '2p'){
        handlePlayerInput(p2, keys);
      } else {
        // AI behavior for p2
        aiBehavior(p2);
      }

      // If puck is attached to someone, position it at their blade
      if(puck.attachedTo === 1){
        const blade = stickEnd(p1);
        puck.x = blade.x; puck.y = blade.y;
      } else if(puck.attachedTo === 2){
        const blade = stickEnd(p2);
        puck.x = blade.x; puck.y = blade.y;
      } else {
        // puck physics
        puck.x += puck.vx; puck.y += puck.vy;
        puck.vx *= 0.995; puck.vy *= 0.995;
      }

      // collisions: if puck near blade and not attached, try attach (auto pickup)
      if(puck.attachedTo === null){
        tryAttach(1);
        tryAttach(2);
      }

      // prevent escape off canvas (with slight bounce)
      if(puck.x - puck.r < 0) { puck.x = puck.r; puck.vx *= -0.6; }
      if(puck.x + puck.r > canvas.width) { puck.x = canvas.width - puck.r; puck.vx *= -0.6; }
      if(puck.y - puck.r < 0) { puck.y = puck.r; puck.vy *= -0.6; }
      if(puck.y + puck.r > canvas.height) { puck.y = canvas.height - puck.r; puck.vy *= -0.6; }

      // check goals (simple center goal rectangles)
      const goalTop = canvas.height/2 - 30;
      const goalBottom = canvas.height/2 + 30;
      if(puck.x - puck.r <= 8 && puck.y > goalTop && puck.y < goalBottom){
        // goal for right-side player (p2)
        p2Score++;
        updateScoreboard();
        resetPositions();
      }
      if(puck.x + puck.r >= canvas.width - 8 && puck.y > goalTop && puck.y < goalBottom){
        // goal for left-side player (p1)
        p1Score++;
        updateScoreboard();
        resetPositions();
      }

      // reduce poke cooldowns
      if(p1.pokeCooldown > 0) p1.pokeCooldown--;
      if(p2.pokeCooldown > 0) p2.pokeCooldown--;
    }

    function handlePlayerInput(pl, keysState){
      if(!pl) return;
      // movement
      if(pl.controls.up && keysState[pl.controls.up]) pl.y -= pl.speed;
      if(pl.controls.down && keysState[pl.controls.down]) pl.y += pl.speed;
      if(pl.controls.left && keysState[pl.controls.left]) pl.x -= pl.speed;
      if(pl.controls.right && keysState[pl.controls.right]) pl.x += pl.speed;

      // update facing direction if moving
      let vx = (pl.controls.right && keysState[pl.controls.right] ? 1 : 0) - (pl.controls.left && keysState[pl.controls.left] ? 1:0);
      let vy = (pl.controls.down && keysState[pl.controls.down] ? 1 : 0) - (pl.controls.up && keysState[pl.controls.up] ? 1:0);
      if(vx !== 0 || vy !== 0) {
        pl.dir = Math.atan2(vy, vx);
      }

      // shoot
      if(pl.controls.shoot && keysState[pl.controls.shoot]) {
        // press once per keydown: to avoid repeated shots while key held, clear key after shoot
        if(pl.controls.shoot === ' '){
          // prevent the browser's default scroll behavior already blocked
        }
        shoot(pl === p1 ? 1 : 2);
        // small delay: require key release to shoot again
        keysState[pl.controls.shoot] = false;
      }

      // poke
      if(pl.controls.poke && keysState[pl.controls.poke] && pl.pokeCooldown <= 0){
        pokeCheck(pl === p1 ? 1 : 2);
        keysState[pl.controls.poke] = false;
      }

      // bounds
      pl.x = Math.max(20, Math.min(canvas.width - 20, pl.x));
      pl.y = Math.max(30, Math.min(canvas.height - 30, pl.y));
    }

    function aiBehavior(ai){
      // Very simple AI: if it holds the puck, drive toward left goal and shoot when in range.
      // Otherwise chase puck and attempt to attach / poke.
      if(!ai) return;
      // if attached, move toward left goal (defender's goal is left)
      if(puck.attachedTo === 2){
        // move toward left goal x ~ 30, center y
        const targetY = canvas.height/2;
        const targetX = 60;
        if(ai.y < targetY) ai.y += ai.speed*0.9;
        if(ai.y > targetY) ai.y -= ai.speed*0.9;
        if(ai.x > targetX) ai.x -= ai.speed*0.9;
        // shoot when close enough to goal
        if(ai.x < 120){
          shoot(2);
        }
      } else {
        // not attached: move toward puck
        const dx = puck.x - ai.x;
        const dy = puck.y - ai.y;
        const dist = Math.hypot(dx,dy);
        if(dist > 6){
          ai.x += (dx/dist) * ai.speed * 0.9;
          ai.y += (dy/dist) * ai.speed * 0.9;
          ai.dir = Math.atan2(dy,dx);
        }
        // try to poke/attach when close
        if(dist < 28 && ai.pokeCooldown <= 0){
          // 50% chance to poke vs attach
          if(Math.random() < 0.6) {
            tryAttach(2);
          } else {
            pokeCheck(2);
          }
        }
      }
      // clamp
      ai.x = Math.max(20, Math.min(canvas.width - 20, ai.x));
      ai.y = Math.max(30, Math.min(canvas.height - 30, ai.y));
    }

    // drawing functions
    function drawRink(){
      // rink background
      ctx.fillStyle = "#eaf6ff";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // outer
      ctx.strokeStyle = "#0b263b";
      ctx.lineWidth = 2;
      ctx.strokeRect(0,0,canvas.width,canvas.height);

      // center red line
      ctx.strokeStyle = "red";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(canvas.width/2, 0);
      ctx.lineTo(canvas.width/2, canvas.height);
      ctx.stroke();

      // blue lines
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(canvas.width/3, 0);
      ctx.lineTo(canvas.width/3, canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(2*canvas.width/3, 0);
      ctx.lineTo(2*canvas.width/3, canvas.height);
      ctx.stroke();

      // faceoff circle (center)
      ctx.strokeStyle = "red";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(canvas.width/2, canvas.height/2, 28, 0, Math.PI*2);
      ctx.stroke();

      // goals (simple rects)
      ctx.fillStyle = "#d3d6db";
      ctx.fillRect(0, canvas.height/2 - 30, 8, 60);
      ctx.fillRect(canvas.width - 8, canvas.height/2 - 30, 8, 60);

      // goal creases (blue arcs)
      ctx.strokeStyle = "rgba(0,85,170,0.9)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(8, canvas.height/2, 30, -Math.PI/2, Math.PI/2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(canvas.width-8, canvas.height/2, 30, Math.PI/2, -Math.PI/2);
      ctx.stroke();
    }

    function drawPlayer(pl, colorFill){
      // stick pivot is pl.x,pl.y
      ctx.lineWidth = 3;
      ctx.strokeStyle = "#222";
      // head
      ctx.beginPath();
      ctx.arc(pl.x, pl.y - 18, 6, 0, Math.PI*2);
      ctx.stroke();
      // body
      ctx.beginPath();
      ctx.moveTo(pl.x, pl.y - 12);
      ctx.lineTo(pl.x, pl.y + 12);
      ctx.stroke();
      // arms
      ctx.beginPath();
      ctx.moveTo(pl.x - 12, pl.y - 2);
      ctx.lineTo(pl.x + 12, pl.y - 2);
      ctx.stroke();
      // legs
      ctx.beginPath();
      ctx.moveTo(pl.x, pl.y + 12);
      ctx.lineTo(pl.x - 8, pl.y + 28);
      ctx.moveTo(pl.x, pl.y + 12);
      ctx.lineTo(pl.x + 8, pl.y + 28);
      ctx.stroke();

      // draw stick as shaft + blade (blade angled)
      const angle = pl.dir;
      const shaftStartX = pl.x + Math.cos(angle) * 8;
      const shaftStartY = pl.y + Math.sin(angle) * 8 - 4;
      const shaftEndX = pl.x + Math.cos(angle) * (pl.bladeOffset - 6);
      const shaftEndY = pl.y + Math.sin(angle) * (pl.bladeOffset - 6) - 4;

      // shaft
      ctx.strokeStyle = "#6b3f1b";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(shaftStartX, shaftStartY);
      ctx.lineTo(shaftEndX, shaftEndY);
      ctx.stroke();

      // blade (small L shape)
      ctx.lineWidth = 4;
      ctx.strokeStyle = "#222";
      const bladeX = pl.x + Math.cos(angle) * (pl.bladeOffset);
      const bladeY = pl.y + Math.sin(angle) * (pl.bladeOffset);
      // blade angle slightly rotated downwards to resemble hockey blade
      ctx.beginPath();
      ctx.moveTo(shaftEndX, shaftEndY);
      ctx.lineTo(bladeX, bladeY);
      ctx.lineTo(bladeX + Math.cos(angle + Math.PI/2) * 8, bladeY + Math.sin(angle + Math.PI/2) * 8);
      ctx.stroke();

      // highlight blade if holding puck
      if(pl.holding){
        ctx.fillStyle = "rgba(0,150,0,0.2)";
        ctx.beginPath();
        ctx.arc(bladeX, bladeY, 10, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function drawPuck(){
      ctx.fillStyle = "#111";
      ctx.beginPath();
      ctx.arc(puck.x, puck.y, puck.r, 0, Math.PI*2);
      ctx.fill();
    }

    function resetPositions(){
      p1.x = 80; p1.y = canvas.height/2; p1.dir = 0; p1.holding = false;
      p2.x = canvas.width-80; p2.y = canvas.height/2; p2.dir = Math.PI; p2.holding = false;
      puck = makePuck();
    }

    function loop(){
      update();
      // draw
      drawRink();
      drawPlayer(p1);
      drawPlayer(p2);
      drawPuck();
      loopId = requestAnimationFrame(loop);
    }

    // Shoot/shove handlers (public)
    function shoot(which){ // which: 1 or 2
      const pl = which === 1 ? p1 : p2;
      if(!pl) return;
      if(puck.attachedTo === which){
        // direction = pl.dir, power influenced by player's small random variation
        const power = 7.5 + Math.random()*1.8;
        puck.vx = Math.cos(pl.dir) * power;
        puck.vy = Math.sin(pl.dir) * power;
        puck.attachedTo = null;
        pl.holding = false;
        pl.pokeCooldown = 8;
      } else {
        // if not attached, attempt quick attach if near blade
        tryAttach(which);
      }
    }

    // expose shoot via keys (space/enter)
    // Note: we handle in handlePlayerInput to avoid continuous fire on hold

    // initial draw
    (function initStatic(){
      // draw an initial rink
      drawRink();
      // placeholder players & puck while on home screen
      const tmpP1 = makePlayer(80, canvas.height/2, {});
      const tmpP2 = makePlayer(canvas.width-80, canvas.height/2, {});
      drawPlayer(tmpP1); drawPlayer(tmpP2);
      const tmpPuck = makePuck();
      drawPuck();
    })();

    // Start main loop when game started in startGame()
    // Expose controls so keyboard functions work:
    window.shootP1 = () => shoot(1);
    window.shootP2 = () => shoot(2);

    // Tie shooting to keypresses (space for P1, Enter for P2) inside input handler already
    // We handled shooting inside handlePlayerInput to ensure single-shot per keypress.

    // Prevent accidental page scrolling for arrow/space
    window.addEventListener('keydown', function(e){
      if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
      // Space and Enter handled by input system (we set keys to false after using them to avoid repeats)
    });

    // make sure scoreboard updates visually on start or goal
    function updateScoreboard(){ updateScoreboard; } // placeholder to avoid linter warning (actual updates called elsewhere)

    // ensure UI elements exist and update function reachable
    window.updateScoreboard = function(){
      p1ScoreEl.textContent = p1Score;
      p2ScoreEl.textContent = p2Score;
    };

    // safety: ensure game resets cleanly on page visibility change
    document.addEventListener('visibilitychange', () => {
      if(document.hidden) cancelAnimationFrame(loopId);
    });
  </script>
</body>
</html>
